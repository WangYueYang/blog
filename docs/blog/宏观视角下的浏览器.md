# 宏观视角下的浏览器

## 01. Chrome架构：仅仅打开了1个页面，为什么有4个进程？

### 进程和线程

#### 什么是并行处理
计算机中的并行处理就是同一时刻处理多个任务

#### 线程 VS 进程
多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

总结来说，进程和线程之间的关系有以下 4 个特点:

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
4. 进程之间的内容相互隔离。进程之间使用 IPC 通信

#### 目前的多进程浏览器架构
最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

所以为什么打开一个页面会有四个进程： 因为至少需要 1 个网络进程， 1 个浏览器主进程， 1 个 GPU 进程， 1 个渲染进程。如果打开的页面还有运行插件的话，还需要再加上 1 个插件进程。

## 02. TCP协议：如何保证页面文件能被完整送达浏览器？

### 1. IP： 把数据包送达目的主机
数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。

计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

当你想要把一个数据包从主机 A 发送给主机 B，那么在传输之前数据包上会加上主机 B 的 IP 地址信息，这样才能够找到主机 B。额外的，数据包上还会附加上主机 A 的 IP 地址，这样主机 B 才能够回复主机 A。而这些附加的信息会呗装进一个叫 IP 头的数据结构里面。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

所以简单点来说，IP 协议是为你的包裹（数据包）加上你想要到达的地址，可以附加上你自己的地址以及其他信息，可以让对方找到你。IP 协议存在于网络层中。

### 2. UDP：把数据包送达应用程序
IP 协议只负责把数据包传送到对方电脑，但是对方电脑并不知道吧数据包交给哪个程序。因此需要基于 IP 协议之上能和应用打交道的协议，最常见的就是 UDP 协议 -- “用户数据包协议（User Datagram Protocol）”

UDP 中一个最重要的信息是端口号，没个想访问网络的程序都需要绑定一个端口号，通过端口号 UDP 就可以把指定的数据包发送给制定的程序。所以 IP 协议负责把数据包传给制定的电脑， UDP 通过端口号把数据包分发给制定的错程序。UDP 协议存在于 IP 协议更上层的传输层中。

UDP 的缺点：他只知道吧数据包扔给目的地，但是并不关目的地是否在线，是否已经接受到，不管数据包是否出错。但是他的传输速度很快，所以适合在一些关注速度，但是对数据完整性要求不那么严格的场景，比如在线视频，互动游戏等

### 3. TCP：把数据完整地送达应用程序
对于浏览器请求，或是其他要求数据可靠性的应用，UDP 传输会有两个问题：

1. 数据包在传输过程中容易丢失
1. 大文件会呗拆分成多个小数据包来传输，UDP 不知道如何组装这些数据包，也就无法还原成愿文件

为了解决 UDP 的问题，所以有了 TCP 协议，相对于 UDP ， TCP 有一下两个特点：

1. 对于丢失的数据包，TCP 有重传机制
1. TCP 引入了数据包排序机制，可以吧混乱的数据包组合成一个完整的文件

和 UDP 一样，TCP 也是通过端口号来找到对应的应用等。

## 03. HTTP请求流程：为什么很多站点第二次打开速度会很快？

浏览器发起 HTTP 请求流程：

1. 构建请求：浏览器构建请求行信息，构建好后，浏览器准备发起网络请求。
2. 查找缓存： 强缓存和协商缓存。
3. 准备 IP 地址和端口：DNS 解析，获取 IP 地址和端口号，DNS 是会被缓存在浏览器本地的。如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。
1. 等待 TCP 队列： HTTP/1.1 一个 tcp 同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！ 但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求。如果同一域名下有 10 个请求发生，那么会有 4 个请求进入到排队等待状态。
5. 监理 TCP 链接： 通过 TCP 协议和服务器建立连接，因为 HTTP 协议是建立在 TCP 连接基础之上的
1. 发送 HTTP 请求：请求头，请求行，请求体

服务器端处理 HTTP 请求流程：

1. 返回请求：返回响应行，根据状态吗做不同的处理，发送响应体
1. 断开连接：通常情况下，一个请求完成后会关闭 TCP 链接，但是可以通过 `Connection:Keep-Alive` 保持 TCP 连接。可以省去下次请求时需要建立连接的时间，提升资源加载速度。
1. 重定向：暂时重定向和永久重定向，响应行的 location 字段是重定向的地址

所以二次打开速度变快的原因是：缓存。。

## 04. 导航流程：从输入URL到页面展示，这中间发生了什么？

浏览器进程，渲染进程，网络进程的主要责任：

- 浏览器进程主要负责用户交互、子进程管理和文件储存等功能。
- 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
- 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为这一步的所有东西都是通过网络获取到的，所以会存在安全方面的问题，所以浏览器会让渲染进程运行在安全沙箱里。

#### 从宏观的角度来看页面是如何展示的

1. 浏览器主进程接受到用户输入的 URL 请求，浏览器进程把 URL 转发给网络进程
1. 在网络进程中发起真正的 URL 请求
1. 网络进程收到了服务器返回的相应数据，并解析相应数据，把数据转发给浏览器进程
1. 浏览器进程接受到网络进程发送过来的相应数据后，给渲染进程发送 “提交导航（CommitNavigation）” 消息
1. 渲染进程接受到“提交导航”的消息后，开始准备接受 HTML 数据，接受数据的方式是直接和网络进程简历数据管道
1. 渲染进程会告诉浏览器进程，已经准备好接受和解析页面数据了
1. 浏览器进程收到消息后，开始移除之前的旧文档，然后更新浏览器进程中的页面状态

PS：用户发出 URL 请求到页面开始解析的这个过程，叫做“导航”

#### 详细分析一下这些阶段

1. 当用户在地址栏中输入一个查询关键字是，地址栏会判断输入的关键字是搜索内容，还是请求 URL
   1. 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL
   2. 如果是 URL，地址栏会根据规则把这段 URL 加上协议，合成为完整的 URL
   
   > 当用户输入关键字并回车后，意味着当前页面将要被替换成新的页面，在这之前会执行 beforeunload 事件，它允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面
   
2. 浏览器进程通过 IPC 通信把 URL 发送给网络进程，由网络进程发起真正的 URL 请求

3. 网络进程查看本地是否有缓存

   1. 如果有缓存，会拦截请求，并且直接返回资源给浏览器进程
   2. 如果没有本地缓存进行 DNS 解析
      1. 如果浏览器有之前缓存过的 DNS 解析的结果会直接使用
      2. 如果没有 DNS 缓存，对其进行解析，获取到请求服务器的 IP 地址
   3. 通过 TCP/IP 协议 （IP 地址加端口）建立 TCP 连接，开始三次握手
      1. 这里还会有一个等待 TCP 队列的情况，因为浏览器为每个域名最多维护 6 个 TCP 连接
   4. 浏览器构建请求头，请求行等信息，并把域名相关的 cookie 等数据发送给服务器
   5. 服务器接受到请求信息后，会根据请求信息生成相应数据，发送给网络进程
   6. 网络进程接受到相应数据后开始解析相应头的内容，并且根据不同的状态码做不同的处理
      1. 重定向处理：对于状态码是 301 或 302 时，网络进程会从相应头的 location 字段里读取重定向地址，然后发起新的 HTTP 请求
      2. 正常相应 200：浏览器会根据 `Content-Type` 字段来区分服务器返回的响应数据时什么类型的，以此决定如何显示相应数据。如果是 HTML 那么浏览器会继续进行导航流程
   7. 浏览器准备渲染进程，默认情况下，每新开一个页面浏览器就会配套创建一个新的渲染进程。但是当新页面和当前页面属于同一站点（根域名和协议都相同）的话，那么新页面会复用父页面的渲染进程。
   8. 浏览器进程把从网络进程接受到的 HTML 数据提交给渲染进程
      1. 浏览器进程接受到网络进程的响应数据后，向渲染进程发起“提交文档”的消息
      2. 渲染进程接收到后，会和网络进程建立传输数据的“管道”
      3. 当文档数据传输完成后，渲染进程会高数浏览器进程
      4. 浏览器接收到提示后，会更新浏览器界面的状态，包括了：安全状态，地址栏里的 URL，前进后退的历史状态，并更新 web 页面
   9. 渲染阶段，渲染进程开始页面解析和子资源加载

## 05. 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？

1. 根据 HTML 内容构建 DOM 树，因为浏览器无法直接使用和理解 HTML
2. 渲染引擎接收到 CSS 文本后会转换为浏览器可以理解的结构—— styleSheets，在浏览器的控制台中，可以通过 `document.styleSheets` 查看
3. 转换样式表中的属性值，让他标准化。比如： red 被转为 rgba(255,0,0)，2em 被转为具体的像素 px
4. 计算出 DOM 节点中每个元素的具体样式，并且在计算过程中需要遵循 CSS 的继承和层叠两个规则。
5. 开始布局阶段，在这个阶段中会计算出 DOM 树中可见元素的位置
   1. 创建布局树，在显示之前还会额外构建一颗只包含可见元素的布局树
   2. 计算布局树街店的坐标位置


## 06. 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？

####  分层

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

[如何在开发者工具中可视化查看页面](https://www.cnblogs.com/HenrysBlogs/p/13419843.html)

##### 满足什么条件，渲染引擎才会为特定节点创建新的图层？

1. 拥有层叠上下文属性的元素 [关于层叠上下文](https://developer.mozilla.org/zh-CN/docs/web/css/css_positioning/understanding_z_index/the_stacking_context)
2. 需要被裁剪的地方也会被创建为图层，比如有一个固定宽高，设置了 overflow: auto 的 div 他的内容超出 div 所显示的区域就会产生裁剪。出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

#### 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

#### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，合成线程会将图层划分为很多个图块（tile），这些图块的大小通常是 256 * 256 || 512 * 512。

然后合成线程会按照视口（可视窗口）附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

#### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面接收到合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

#### 渲染流水线大总结

1. 生成 DOM 树
2. 生成 styleSheets，计算出 DOM 节点的样式
3. 创建布局树，计算元素的布局信息
4. 对布局树进行分成，生成分层树
5. 为每个图层生成绘制列表，把他提交给合成线程
6. 合成线程把图层分成图块，在栅格化过程中把图块转化为位图
7. 合成线程发送绘制图块命令给浏览器进程
8. 浏览器根据消息生成页面，显示在浏览器上

