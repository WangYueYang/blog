# V8工作原理

## 12. 栈空间和堆空间：数据是如何存储的？

在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。

通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

## 13. 垃圾回收：垃圾数据是如何自动回收的？

### 为什么需要垃圾回收机制
有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。

### 调用栈中的数据是如何回收的
在调用栈中有一个记录当前执行状态的指针（称为 ESP），指向调用栈中函数的执行上下文，表示丹铅正在执行的函数。当前函数执行完成后就需要销毁当前函数的执行上下文， JS 会通过将 ESP 下移指向下一个函数来进行销毁。当 ESP 下移以后虽然原来的函数依然保存在栈内存中，但是已经是无效内存了，当有新的函数再次入栈时，会直接覆盖掉原有函数。

### 堆中的数据时如何回收的

#### 代际假说和分代收集
这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。

代际假说有以下两个特点：

1. 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
1. 第二个是不死的对象，会活得更久。

在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- 副垃圾回收器，主要负责新生代的垃圾回收。
- 主垃圾回收器，主要负责老生代的垃圾回收。

#### 垃圾回收器的工作流程
其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

#### 副垃圾回收器
副垃圾回收器主要负责新生区的垃圾回收。新生代中用 Scavenge 算法来处理，他会把新生区分为两个部分：对象区域和空闲区域，新加入的对象都会存在对象区域中，当对象区域要写满的时候就会执行一次垃圾清理。

在回收过程中，首先对对象区域中的垃圾做标记，标记完成后会进行清理，接着副垃圾回收器会把存活的对象复制到空闲区域中，并且还会把这些对象进行有序的排列，这样就没有内存碎片了。

完成复制后，对象区域和空闲区域会进行角色反转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

#### 主垃圾回收器

主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

他会在标记过程中找到没有引用的对象，将它标记为红色，对于还在使用的对象会被标记为活动对象。然后清除掉红色标记的数据，对于出现大量不连续的内存这种情况他会让所有存货的对象都向一端移动，然后直接清理掉端边界以外的内存。


