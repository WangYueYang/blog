# 浏览器中的JavaScript执行机制

## 07. 变量提升：JavaScript代码是按顺序执行的吗？

### 变量提升（Hoisting）
所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。

### JavaScript 代码的执行流程
实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

大致流程为：

> 一段Javascript代码 ----> 编译阶段 ----> 执行阶段

#### 1. 编译阶段

输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容

你可以简单地把变量环境对象看成是如下结构：

```js
VariableEnvironment:
     myname -> undefined, 
     showName ->function : {console.log(myname)
```
Js 是如何生成变量环境对象的：

1. JS 对于声明操作会在变量环境对象中创建一个对应的属性，并且使用 undefined 对其初始化
1. JS 引擎发现了一个通过 function 定义的函数时，会将函数定义存储到堆中，并在环境对象中创建一个对应的属性，然后将该属性指向堆中函数的位置

这样就生成了变量环境对象。接下来 JavaScript 引擎会把声明以外的代码编译为字节码。有了执行上下文和可执行代码了，那么接下来就到了执行阶段了。

#### 2.执行阶段

JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。而如果一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。因为在编译阶段中第二个函数会覆盖掉第一个函数在变量环境对象中属性的指向。

## 08. 调用栈：为什么JavaScript代码会出现栈溢出？

当一段代码符合一下条件被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。

1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
1. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
1. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

#### JavaScript 的调用站
1. 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码
1. 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
1. 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
1. 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

## 09. 块级作用域：var缺陷以及为什么要引入let和const？

由于 JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题

#### JavaScript 是如何支持块级作用域的

1. 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
1. 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。
1. 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。
1. 当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量
1. 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出
1. 当需要在词法环境和变量环境中查找某个值的时候，具体查找的方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。

## 10. 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

### 作用域链
在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果没有找到那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。我们把这个查找的链条就称为作用域链。

### 词法作用域

在 JS 执行过程中其作用域链是由词法作用域决定的。

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。

### 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包

### 闭包是怎么回收的

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## 11. this：从JavaScript执行上下文的视角讲清楚this

### JavaScript 中的 this 是什么
this 是和执行上下文绑定的，所以与之对应的 this 有三种 —— 全局上下文 this， 函数上下文 this， eval 上下文 this。

在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。

通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。
